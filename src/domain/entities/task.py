from dataclasses import dataclass, field
from datetime import date, datetime
from enum import Enum

from domain.constants import SECONDS_PER_HOUR
from domain.exceptions.task_exceptions import TaskValidationError


class TaskStatus(Enum):
    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    CANCELED = "CANCELED"


@dataclass
class Task:
    """Task entity representing a task with time management.

    Attributes:
        name: Task name
        priority: Task priority (higher number = higher priority)
        id: Unique task identifier (auto-generated by repository)
        status: Current task status
        created_at: Created at timestamp
        planned_start: Planned start datetime
        planned_end: Planned end datetime
        deadline: Deadline datetime
        actual_start: Actual start datetime (set when status → IN_PROGRESS)
        actual_end: Actual end datetime (set when status → COMPLETED/CANCELED)
        estimated_duration: Estimated duration in hours
        daily_allocations: Daily work hours allocation (date_str → hours)
        depends_on: List of task IDs that must be completed before this task can start
        is_fixed: Whether this task is fixed (cannot be moved by optimizer)
        actual_daily_hours: Actual work hours per day (date_str → hours)
        is_deleted: Whether this task is logically deleted (soft delete)
    """

    name: str
    priority: int
    id: int | None = None
    status: TaskStatus = field(default_factory=lambda: TaskStatus.PENDING)
    created_at: datetime = field(default_factory=datetime.now)
    planned_start: datetime | None = None
    planned_end: datetime | None = None
    deadline: datetime | None = None
    actual_start: datetime | None = None
    actual_end: datetime | None = None
    estimated_duration: float | None = None
    daily_allocations: dict[date, float] = field(default_factory=dict)
    # New fields (Phase 1: Schema extension)
    depends_on: list[int] = field(default_factory=list)
    is_fixed: bool = False
    actual_daily_hours: dict[date, float] = field(default_factory=dict)
    is_deleted: bool = False

    def __post_init__(self) -> None:
        """Validate entity invariants after initialization.

        Ensures that the Task entity always maintains a valid state by checking:
        - Task name is not empty or whitespace-only
        - Priority is a positive integer
        - Estimated duration (if provided) is a positive number

        Raises:
            TaskValidationError: If any invariant is violated
        """
        # Validate name (required and non-empty)
        if not self.name or not self.name.strip():
            raise TaskValidationError("Task name cannot be empty")

        # Validate priority (must be positive)
        if self.priority <= 0:
            raise TaskValidationError("Priority must be greater than 0")

        # Validate estimated_duration (if provided, must be positive)
        if self.estimated_duration is not None and self.estimated_duration <= 0:
            raise TaskValidationError("Estimated duration must be greater than 0")

    @property
    def actual_duration_hours(self) -> float | None:
        """Calculate actual duration in hours from actual_start and actual_end"""
        if not self.actual_start or not self.actual_end:
            return None

        duration = (self.actual_end - self.actual_start).total_seconds() / SECONDS_PER_HOUR
        return round(duration, 1)

    @property
    def is_active(self) -> bool:
        """Check if task is in active state (work in progress or pending).

        Returns:
            True if task status is PENDING or IN_PROGRESS
        """
        return self.status in (TaskStatus.PENDING, TaskStatus.IN_PROGRESS)

    @property
    def is_finished(self) -> bool:
        """Check if task is in finished state (completed or canceled).

        Returns:
            True if task status is COMPLETED or CANCELED
        """
        return self.status in (TaskStatus.COMPLETED, TaskStatus.CANCELED)

    @property
    def can_be_modified(self) -> bool:
        """Check if task can be modified (not deleted).

        Deleted tasks should not be updated.

        Returns:
            True if task is not deleted
        """
        return not self.is_deleted

    def is_schedulable(self, force_override: bool = False) -> bool:
        """Check if task can be scheduled.

        Args:
            force_override: Whether to allow rescheduling of already-scheduled tasks

        Returns:
            True if task can be scheduled

        Business Rules:
            - Must have estimated_duration set
            - Must be PENDING status (not IN_PROGRESS, COMPLETED, or CANCELED)
            - Must not be deleted
            - Must not be fixed (always protected, even with force_override)
            - If force_override is False, must not have existing schedule
        """
        # Skip deleted tasks
        if self.is_deleted:
            return False

        # Skip finished tasks
        if self.is_finished:
            return False

        # Skip IN_PROGRESS tasks (don't reschedule tasks already being worked on)
        if self.status == TaskStatus.IN_PROGRESS:
            return False

        # Skip tasks without estimated duration
        if not self.estimated_duration:
            return False

        # Skip fixed tasks (always, even with force_override)
        # Fixed tasks represent immovable constraints (meetings, deadlines, etc.)
        if self.is_fixed:
            return False

        # Allow scheduling if no existing schedule OR if force_override is True
        return not (self.planned_start and not force_override)

    def should_count_in_workload(self) -> bool:
        """Check if task should be counted in workload calculations.

        Returns:
            True if task should be included in workload

        Business Rules:
            - Exclude finished tasks (COMPLETED, CANCELED)
            - Exclude deleted tasks
            - Include PENDING and IN_PROGRESS tasks
        """
        return not self.is_finished and not self.is_deleted

    def to_dict(self) -> dict:
        """Serialize task to dictionary for persistence.

        Datetime fields are serialized to ISO 8601 format strings for JSON compatibility.

        Returns:
            Dictionary containing all task fields
        """
        return {
            "id": self.id,
            "name": self.name,
            "priority": self.priority,
            "status": self.status.value,
            "created_at": self.created_at.isoformat()
            if isinstance(self.created_at, datetime)
            else self.created_at,
            "planned_start": self.planned_start.isoformat()
            if isinstance(self.planned_start, datetime)
            else self.planned_start,
            "planned_end": self.planned_end.isoformat()
            if isinstance(self.planned_end, datetime)
            else self.planned_end,
            "deadline": self.deadline.isoformat()
            if isinstance(self.deadline, datetime)
            else self.deadline,
            "actual_start": self.actual_start.isoformat()
            if isinstance(self.actual_start, datetime)
            else self.actual_start,
            "actual_end": self.actual_end.isoformat()
            if isinstance(self.actual_end, datetime)
            else self.actual_end,
            "estimated_duration": self.estimated_duration,
            "daily_allocations": {k.isoformat(): v for k, v in self.daily_allocations.items()}
            if self.daily_allocations
            else {},
            "depends_on": self.depends_on,
            "is_fixed": self.is_fixed,
            "actual_daily_hours": {k.isoformat(): v for k, v in self.actual_daily_hours.items()}
            if self.actual_daily_hours
            else {},
            "is_deleted": self.is_deleted,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "Task":
        """Deserialize task from dictionary.

        Supports both string (legacy format) and datetime object formats for backward compatibility.
        String formats supported:
        - ISO 8601: "YYYY-MM-DDTHH:MM:SS" (new format)
        - Legacy: "YYYY-MM-DD HH:MM:SS" (old format)

        Args:
            data: Dictionary containing task fields

        Returns:
            Task instance
        """
        task_data = data.copy()

        # Backward compatibility: support both 'timestamp' and 'created_at'
        if "timestamp" in task_data and "created_at" not in task_data:
            task_data["created_at"] = task_data.pop("timestamp")

        # Convert created_at to datetime if it's a Unix timestamp (float/int)
        if "created_at" in task_data:
            value = task_data["created_at"]
            if isinstance(value, int | float):
                # Convert Unix timestamp to datetime
                task_data["created_at"] = datetime.fromtimestamp(value)
            elif isinstance(value, str):
                # Convert string to datetime
                task_data["created_at"] = cls._parse_datetime_string(value)

        # Convert status string to Enum if present
        if "status" in task_data and isinstance(task_data["status"], str):
            task_data["status"] = TaskStatus(task_data["status"])

        # Convert datetime string fields to datetime objects (backward compatibility)
        datetime_fields = ["planned_start", "planned_end", "deadline", "actual_start", "actual_end"]
        for field_name in datetime_fields:
            if field_name in task_data and isinstance(task_data[field_name], str):
                task_data[field_name] = cls._parse_datetime_string(task_data[field_name])

        # Convert daily_allocations from dict[str, float] to dict[date, float]
        if "daily_allocations" in task_data and isinstance(task_data["daily_allocations"], dict):
            task_data["daily_allocations"] = cls._parse_date_dict(task_data["daily_allocations"])

        # Convert actual_daily_hours from dict[str, float] to dict[date, float]
        if "actual_daily_hours" in task_data and isinstance(task_data["actual_daily_hours"], dict):
            task_data["actual_daily_hours"] = cls._parse_date_dict(task_data["actual_daily_hours"])

        return cls(**task_data)

    @staticmethod
    def _parse_datetime_string(dt_str: str | None) -> datetime | None:
        """Parse datetime string in multiple formats.

        Supports:
        - ISO 8601: "YYYY-MM-DDTHH:MM:SS"
        - Legacy: "YYYY-MM-DD HH:MM:SS"

        Args:
            dt_str: Datetime string to parse

        Returns:
            datetime object or None if parsing fails
        """
        if not dt_str:
            return None

        # Try ISO 8601 format first (new format)
        try:
            return datetime.fromisoformat(dt_str)
        except (ValueError, AttributeError):
            pass

        # Try legacy format: "YYYY-MM-DD HH:MM:SS"
        try:
            from shared.constants.formats import DATETIME_FORMAT

            return datetime.strptime(dt_str, DATETIME_FORMAT)
        except (ValueError, ImportError):
            return None

    @staticmethod
    def _parse_date_dict(date_dict: dict[str, float]) -> dict[date, float]:
        """Parse dictionary with date string keys to date object keys.

        Args:
            date_dict: Dictionary with date strings as keys (YYYY-MM-DD format)

        Returns:
            Dictionary with date objects as keys
        """
        result: dict[date, float] = {}
        for date_str, value in date_dict.items():
            try:
                # Parse ISO format date string
                date_obj = date.fromisoformat(date_str)
                result[date_obj] = value
            except (ValueError, AttributeError):
                # Skip invalid date strings
                pass
        return result
