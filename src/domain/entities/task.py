import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path

from domain.constants import DATETIME_FORMAT
from domain.exceptions.task_exceptions import TaskValidationError
from shared.constants.time import MIN_FILE_SIZE_FOR_CONTENT, SECONDS_PER_HOUR
from shared.xdg_utils import XDGDirectories


class TaskStatus(Enum):
    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    CANCELED = "CANCELED"


@dataclass
class Task:
    """Task entity representing a task with time management.

    Attributes:
        name: Task name
        priority: Task priority (higher number = higher priority)
        id: Unique task identifier (auto-generated by repository)
        status: Current task status
        timestamp: Creation timestamp (Unix time)
        planned_start: Planned start datetime string
        planned_end: Planned end datetime string
        deadline: Deadline datetime string
        actual_start: Actual start datetime string (set when status → IN_PROGRESS)
        actual_end: Actual end datetime string (set when status → COMPLETED/CANCELED)
        estimated_duration: Estimated duration in hours
        daily_allocations: Daily work hours allocation (date_str → hours)
        depends_on: List of task IDs that must be completed before this task can start
        is_fixed: Whether this task is fixed (cannot be moved by optimizer)
        actual_daily_hours: Actual work hours per day (date_str → hours)
        is_deleted: Whether this task is logically deleted (soft delete)
    """

    name: str
    priority: int
    id: int | None = None
    status: TaskStatus = field(default_factory=lambda: TaskStatus.PENDING)
    timestamp: float = field(default_factory=time.time)
    planned_start: str | None = None
    planned_end: str | None = None
    deadline: str | None = None
    actual_start: str | None = None
    actual_end: str | None = None
    estimated_duration: float | None = None
    daily_allocations: dict[str, float] = field(default_factory=dict)
    # New fields (Phase 1: Schema extension)
    depends_on: list[int] = field(default_factory=list)
    is_fixed: bool = False
    actual_daily_hours: dict[str, float] = field(default_factory=dict)
    is_deleted: bool = False

    def __post_init__(self) -> None:
        """Validate entity invariants after initialization.

        Ensures that the Task entity always maintains a valid state by checking:
        - Task name is not empty or whitespace-only
        - Priority is a positive integer
        - Estimated duration (if provided) is a positive number

        Raises:
            TaskValidationError: If any invariant is violated
        """
        # Validate name (required and non-empty)
        if not self.name or not self.name.strip():
            raise TaskValidationError("Task name cannot be empty")

        # Validate priority (must be positive)
        if self.priority <= 0:
            raise TaskValidationError("Priority must be greater than 0")

        # Validate estimated_duration (if provided, must be positive)
        if self.estimated_duration is not None and self.estimated_duration <= 0:
            raise TaskValidationError("Estimated duration must be greater than 0")

    @property
    def created_at_str(self) -> str:
        """Return human-readable creation timestamp"""
        return datetime.fromtimestamp(self.timestamp).strftime(DATETIME_FORMAT)

    @property
    def actual_duration_hours(self) -> float | None:
        """Calculate actual duration in hours from actual_start and actual_end"""
        if not self.actual_start or not self.actual_end:
            return None

        start = datetime.strptime(self.actual_start, DATETIME_FORMAT)
        end = datetime.strptime(self.actual_end, DATETIME_FORMAT)
        duration = (end - start).total_seconds() / SECONDS_PER_HOUR
        return round(duration, 1)

    @property
    def notes_path(self) -> Path:
        """Return path to task's markdown notes file.

        Returns:
            Path to notes file at $XDG_DATA_HOME/taskdog/notes/{id}.md
        """
        return XDGDirectories.get_note_file(self.id)

    @property
    def is_active(self) -> bool:
        """Check if task is in active state (work in progress or pending).

        Returns:
            True if task status is PENDING or IN_PROGRESS
        """
        return self.status in (TaskStatus.PENDING, TaskStatus.IN_PROGRESS)

    @property
    def is_finished(self) -> bool:
        """Check if task is in finished state (completed or canceled).

        Returns:
            True if task status is COMPLETED or CANCELED
        """
        return self.status in (TaskStatus.COMPLETED, TaskStatus.CANCELED)

    @property
    def can_be_modified(self) -> bool:
        """Check if task can be modified (not deleted).

        Deleted tasks should not be updated.

        Returns:
            True if task is not deleted
        """
        return not self.is_deleted

    @property
    def has_note(self) -> bool:
        """Check if task has an associated note file.

        Returns:
            True if notes file exists and has content
        """
        return (
            self.notes_path.exists() and self.notes_path.stat().st_size > MIN_FILE_SIZE_FOR_CONTENT
        )

    def is_schedulable(self, force_override: bool = False) -> bool:
        """Check if task can be scheduled.

        Args:
            force_override: Whether to allow rescheduling of already-scheduled tasks

        Returns:
            True if task can be scheduled

        Business Rules:
            - Must have estimated_duration set
            - Must be PENDING status (not IN_PROGRESS, COMPLETED, or CANCELED)
            - Must not be deleted
            - Must not be fixed (always protected, even with force_override)
            - If force_override is False, must not have existing schedule
        """
        # Skip deleted tasks
        if self.is_deleted:
            return False

        # Skip finished tasks
        if self.is_finished:
            return False

        # Skip IN_PROGRESS tasks (don't reschedule tasks already being worked on)
        if self.status == TaskStatus.IN_PROGRESS:
            return False

        # Skip tasks without estimated duration
        if not self.estimated_duration:
            return False

        # Skip fixed tasks (always, even with force_override)
        # Fixed tasks represent immovable constraints (meetings, deadlines, etc.)
        if self.is_fixed:
            return False

        # Allow scheduling if no existing schedule OR if force_override is True
        return not (self.planned_start and not force_override)

    def should_count_in_workload(self) -> bool:
        """Check if task should be counted in workload calculations.

        Returns:
            True if task should be included in workload

        Business Rules:
            - Exclude finished tasks (COMPLETED, CANCELED)
            - Exclude deleted tasks
            - Include PENDING and IN_PROGRESS tasks
        """
        return not self.is_finished and not self.is_deleted

    def to_dict(self) -> dict:
        """Serialize task to dictionary for persistence.

        Returns:
            Dictionary containing all task fields
        """
        return {
            "id": self.id,
            "name": self.name,
            "priority": self.priority,
            "status": self.status.value,
            "timestamp": self.timestamp,
            "planned_start": self.planned_start,
            "planned_end": self.planned_end,
            "deadline": self.deadline,
            "actual_start": self.actual_start,
            "actual_end": self.actual_end,
            "estimated_duration": self.estimated_duration,
            "daily_allocations": self.daily_allocations,
            "depends_on": self.depends_on,
            "is_fixed": self.is_fixed,
            "actual_daily_hours": self.actual_daily_hours,
            "is_deleted": self.is_deleted,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "Task":
        """Deserialize task from dictionary.

        Args:
            data: Dictionary containing task fields

        Returns:
            Task instance
        """
        # Convert status string to Enum if present
        task_data = data.copy()
        if "status" in task_data and isinstance(task_data["status"], str):
            task_data["status"] = TaskStatus(task_data["status"])
        return cls(**task_data)
