import os
import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path

from domain.constants import DATETIME_FORMAT


class TaskStatus(Enum):
    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    ARCHIVED = "ARCHIVED"


@dataclass
class Task:
    """Task entity representing a task with time management.

    Attributes:
        name: Task name
        priority: Task priority (higher number = higher priority)
        id: Unique task identifier (auto-generated by repository)
        status: Current task status
        timestamp: Creation timestamp (Unix time)
        planned_start: Planned start datetime string
        planned_end: Planned end datetime string
        deadline: Deadline datetime string
        actual_start: Actual start datetime string (set when status → IN_PROGRESS)
        actual_end: Actual end datetime string (set when status → COMPLETED/FAILED)
        estimated_duration: Estimated duration in hours
        daily_allocations: Daily work hours allocation (date_str → hours)
    """

    name: str
    priority: int
    id: int | None = None
    status: TaskStatus = field(default_factory=lambda: TaskStatus.PENDING)
    timestamp: float = field(default_factory=time.time)
    planned_start: str | None = None
    planned_end: str | None = None
    deadline: str | None = None
    actual_start: str | None = None
    actual_end: str | None = None
    estimated_duration: float | None = None
    daily_allocations: dict[str, float] = field(default_factory=dict)

    @property
    def created_at_str(self):
        """Return human-readable creation timestamp"""
        return datetime.fromtimestamp(self.timestamp).strftime(DATETIME_FORMAT)

    @property
    def actual_duration_hours(self):
        """Calculate actual duration in hours from actual_start and actual_end"""
        if not self.actual_start or not self.actual_end:
            return None

        start = datetime.strptime(self.actual_start, DATETIME_FORMAT)
        end = datetime.strptime(self.actual_end, DATETIME_FORMAT)
        duration = (end - start).total_seconds() / 3600
        return round(duration, 1)

    @property
    def notes_path(self) -> Path:
        """Return path to task's markdown notes file.

        Returns:
            Path to notes file at $XDG_DATA_HOME/taskdog/notes/{id}.md
        """
        data_dir = os.getenv("XDG_DATA_HOME", os.path.expanduser("~/.local/share"))
        notes_dir = Path(data_dir) / "taskdog" / "notes"
        return notes_dir / f"{self.id}.md"

    @property
    def is_active(self) -> bool:
        """Check if task is in active state (work in progress or pending).

        Returns:
            True if task status is PENDING or IN_PROGRESS
        """
        return self.status in (TaskStatus.PENDING, TaskStatus.IN_PROGRESS)

    @property
    def is_finished(self) -> bool:
        """Check if task is in finished state (completed, failed, or archived).

        Returns:
            True if task status is COMPLETED, FAILED, or ARCHIVED
        """
        return self.status in (TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.ARCHIVED)

    @property
    def can_be_modified(self) -> bool:
        """Check if task can be modified (not archived).

        Archived tasks should not be updated as they are historical records.

        Returns:
            True if task status is not ARCHIVED
        """
        return self.status != TaskStatus.ARCHIVED

    def to_dict(self) -> dict:
        """Serialize task to dictionary for persistence.

        Returns:
            Dictionary containing all task fields
        """
        return {
            "id": self.id,
            "name": self.name,
            "priority": self.priority,
            "status": self.status.value,
            "timestamp": self.timestamp,
            "planned_start": self.planned_start,
            "planned_end": self.planned_end,
            "deadline": self.deadline,
            "actual_start": self.actual_start,
            "actual_end": self.actual_end,
            "estimated_duration": self.estimated_duration,
            "daily_allocations": self.daily_allocations,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "Task":
        """Deserialize task from dictionary.

        Args:
            data: Dictionary containing task fields

        Returns:
            Task instance
        """
        # Convert status string to Enum if present
        task_data = data.copy()
        if "status" in task_data and isinstance(task_data["status"], str):
            task_data["status"] = TaskStatus(task_data["status"])
        return cls(**task_data)
