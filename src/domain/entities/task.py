from dataclasses import dataclass, field
from datetime import date, datetime
from enum import Enum
from typing import Any

from domain.constants import SECONDS_PER_HOUR
from domain.exceptions.task_exceptions import TaskValidationError


class TaskStatus(Enum):
    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    CANCELED = "CANCELED"


@dataclass
class Task:
    """Task entity representing a task with time management.

    Attributes:
        name: Task name
        priority: Task priority (higher number = higher priority)
        id: Unique task identifier (auto-generated by repository)
        status: Current task status (PENDING, IN_PROGRESS, COMPLETED, CANCELED)
        created_at: Created at timestamp
        updated_at: Updated at timestamp (automatically managed by repository)
        planned_start: Planned start datetime
        planned_end: Planned end datetime
        deadline: Deadline datetime
        actual_start: Actual start datetime (set when status → IN_PROGRESS)
        actual_end: Actual end datetime (set when status → COMPLETED/CANCELED)
        estimated_duration: Estimated duration in hours
        daily_allocations: Daily work hours allocation (date_str → hours)
        depends_on: List of task IDs that must be completed before this task can start
        is_fixed: Whether this task is fixed (cannot be moved by optimizer)
        actual_daily_hours: Actual work hours per day (date_str → hours)
        tags: List of tags for categorization and filtering (non-empty, unique)
        is_archived: Whether this task is archived (soft deleted)

    Design Notes:
        Archive Implementation (2025-10-31):
        - Archiving is implemented as is_archived boolean flag to preserve original task status
        - This aligns with industry standards (Jira, Trello) where archiving is
          a visibility flag rather than a terminal state
        - Benefits:
          * Original status (COMPLETED, CANCELED, etc.) is preserved
          * Restoring returns task to its exact previous state
          * More intuitive: "archived COMPLETED task" vs "ARCHIVED task"
    """

    name: str
    priority: int
    id: int | None = None
    status: TaskStatus = field(default_factory=lambda: TaskStatus.PENDING)
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    planned_start: datetime | None = None
    planned_end: datetime | None = None
    deadline: datetime | None = None
    actual_start: datetime | None = None
    actual_end: datetime | None = None
    estimated_duration: float | None = None
    daily_allocations: dict[date, float] = field(default_factory=dict)
    # New fields (Phase 1: Schema extension)
    depends_on: list[int] = field(default_factory=list)
    is_fixed: bool = False
    actual_daily_hours: dict[date, float] = field(default_factory=dict)
    tags: list[str] = field(default_factory=list)
    # Archive flag: True = soft deleted, preserves original status
    is_archived: bool = False

    def __post_init__(self) -> None:
        """Validate entity invariants after initialization.

        Ensures that the Task entity always maintains a valid state by checking:
        - Task name is not empty or whitespace-only
        - Priority is a positive integer
        - Estimated duration (if provided) is a positive number
        - Tags are non-empty strings and unique

        Raises:
            TaskValidationError: If any invariant is violated
        """
        # Validate name (required and non-empty)
        if not self.name or not self.name.strip():
            raise TaskValidationError("Task name cannot be empty")

        # Validate priority (must be positive)
        if self.priority <= 0:
            raise TaskValidationError("Priority must be greater than 0")

        # Validate estimated_duration (if provided, must be positive)
        if self.estimated_duration is not None and self.estimated_duration <= 0:
            raise TaskValidationError("Estimated duration must be greater than 0")

        # Validate tags (non-empty strings and unique)
        for tag in self.tags:
            if not tag or not tag.strip():
                raise TaskValidationError("Tag cannot be empty")
        if len(self.tags) != len(set(self.tags)):
            raise TaskValidationError("Tags must be unique")

    @property
    def actual_duration_hours(self) -> float | None:
        """Calculate actual duration in hours from actual_start and actual_end"""
        if not self.actual_start or not self.actual_end:
            return None

        duration = (self.actual_end - self.actual_start).total_seconds() / SECONDS_PER_HOUR
        return round(duration, 1)

    @property
    def is_active(self) -> bool:
        """Check if task is in active state (work in progress or pending).

        Returns:
            True if task status is PENDING or IN_PROGRESS
        """
        return self.status in (TaskStatus.PENDING, TaskStatus.IN_PROGRESS)

    @property
    def is_finished(self) -> bool:
        """Check if task is in finished state (completed or canceled).

        Returns:
            True if task status is COMPLETED or CANCELED
        """
        return self.status in (TaskStatus.COMPLETED, TaskStatus.CANCELED)

    @property
    def can_be_modified(self) -> bool:
        """Check if task can be modified (not archived).

        Archived tasks should not be updated.

        Returns:
            True if task is not archived
        """
        return not self.is_archived

    def is_schedulable(self, force_override: bool = False) -> bool:
        """Check if task can be scheduled.

        Args:
            force_override: Whether to allow rescheduling of already-scheduled tasks

        Returns:
            True if task can be scheduled

        Business Rules:
            - Must not be archived
            - Must have estimated_duration set
            - Must be PENDING status (not IN_PROGRESS, COMPLETED, or CANCELED)
            - Must not be fixed (always protected, even with force_override)
            - If force_override is False, must not have existing schedule
        """
        # Skip archived tasks
        if self.is_archived:
            return False

        # Skip finished tasks
        if self.is_finished:
            return False

        # Skip IN_PROGRESS tasks (don't reschedule tasks already being worked on)
        if self.status == TaskStatus.IN_PROGRESS:
            return False

        # Skip tasks without estimated duration
        if not self.estimated_duration:
            return False

        # Skip fixed tasks (always, even with force_override)
        # Fixed tasks represent immovable constraints (meetings, deadlines, etc.)
        if self.is_fixed:
            return False

        # Allow scheduling if no existing schedule OR if force_override is True
        return not (self.planned_start and not force_override)

    def should_count_in_workload(self) -> bool:
        """Check if task should be counted in workload calculations.

        Returns:
            True if task should be included in workload

        Business Rules:
            - Exclude finished tasks (COMPLETED, CANCELED)
            - Include PENDING and IN_PROGRESS tasks
        """
        return not self.is_finished

    @staticmethod
    def _serialize_datetime(dt: datetime | str | None) -> str | None:
        """Serialize datetime to ISO 8601 string format.

        Args:
            dt: Datetime object, string, or None

        Returns:
            ISO 8601 string if datetime object, original value otherwise
        """
        if isinstance(dt, datetime):
            return dt.isoformat()
        return dt

    def to_dict(self) -> dict[str, Any]:
        """Serialize task to dictionary for persistence.

        Datetime fields are serialized to ISO 8601 format strings for JSON compatibility.

        Returns:
            Dictionary containing all task fields
        """
        return {
            "id": self.id,
            "name": self.name,
            "priority": self.priority,
            "status": self.status.value,
            "created_at": self._serialize_datetime(self.created_at),
            "updated_at": self._serialize_datetime(self.updated_at),
            "planned_start": self._serialize_datetime(self.planned_start),
            "planned_end": self._serialize_datetime(self.planned_end),
            "deadline": self._serialize_datetime(self.deadline),
            "actual_start": self._serialize_datetime(self.actual_start),
            "actual_end": self._serialize_datetime(self.actual_end),
            "estimated_duration": self.estimated_duration,
            "daily_allocations": {k.isoformat(): v for k, v in self.daily_allocations.items()}
            if self.daily_allocations
            else {},
            "depends_on": self.depends_on,
            "is_fixed": self.is_fixed,
            "actual_daily_hours": {k.isoformat(): v for k, v in self.actual_daily_hours.items()}
            if self.actual_daily_hours
            else {},
            "tags": self.tags,
            "is_archived": self.is_archived,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "Task":
        """Deserialize task from dictionary.

        Supports both string (legacy format) and datetime object formats for backward compatibility.
        String formats supported:
        - ISO 8601: "YYYY-MM-DDTHH:MM:SS" (new format)
        - Legacy: "YYYY-MM-DD HH:MM:SS" (old format)

        Args:
            data: Dictionary containing task fields

        Returns:
            Task instance
        """
        task_data = data.copy()

        # Backward compatibility: migrate is_deleted to is_archived
        if "is_deleted" in task_data:
            is_deleted = task_data.pop("is_deleted")
            if is_deleted:
                task_data["is_archived"] = True

        # Convert status string to Enum if present
        if "status" in task_data and isinstance(task_data["status"], str):
            task_data["status"] = TaskStatus(task_data["status"])

        # Convert datetime string fields to datetime objects
        datetime_fields = [
            "created_at",
            "updated_at",
            "planned_start",
            "planned_end",
            "deadline",
            "actual_start",
            "actual_end",
        ]
        for field_name in datetime_fields:
            if field_name in task_data and isinstance(task_data[field_name], str):
                task_data[field_name] = cls._parse_datetime_string(task_data[field_name])

        # Convert daily_allocations from dict[str, float] to dict[date, float]
        if "daily_allocations" in task_data and isinstance(task_data["daily_allocations"], dict):
            task_data["daily_allocations"] = cls._parse_date_dict(task_data["daily_allocations"])

        # Convert actual_daily_hours from dict[str, float] to dict[date, float]
        if "actual_daily_hours" in task_data and isinstance(task_data["actual_daily_hours"], dict):
            task_data["actual_daily_hours"] = cls._parse_date_dict(task_data["actual_daily_hours"])

        # Backward compatibility: initialize is_archived as False if not present
        if "is_archived" not in task_data:
            task_data["is_archived"] = False

        # Backward compatibility: initialize tags as empty list if not present
        if "tags" not in task_data:
            task_data["tags"] = []

        return cls(**task_data)

    @staticmethod
    def _parse_datetime_string(dt_str: str | None) -> datetime | None:
        """Parse datetime string in ISO 8601 format.

        Args:
            dt_str: Datetime string in ISO 8601 format (YYYY-MM-DDTHH:MM:SS)

        Returns:
            datetime object or None if parsing fails
        """
        if not dt_str:
            return None

        try:
            return datetime.fromisoformat(dt_str)
        except (ValueError, AttributeError):
            return None

    @staticmethod
    def _parse_date_dict(date_dict: dict[str, float]) -> dict[date, float]:
        """Parse dictionary with date string keys to date object keys.

        Args:
            date_dict: Dictionary with date strings as keys (YYYY-MM-DD format)

        Returns:
            Dictionary with date objects as keys
        """
        result: dict[date, float] = {}
        for date_str, value in date_dict.items():
            try:
                # Parse ISO format date string
                date_obj = date.fromisoformat(date_str)
                result[date_obj] = value
            except (ValueError, AttributeError):
                # Skip invalid date strings
                pass
        return result
