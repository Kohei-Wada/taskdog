from dataclasses import dataclass, field
from datetime import date, datetime
from enum import Enum

from taskdog_core.domain.constants import SECONDS_PER_HOUR
from taskdog_core.domain.exceptions.task_exceptions import TaskValidationError


class TaskStatus(Enum):
    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    CANCELED = "CANCELED"


@dataclass
class Task:
    """Task entity representing a task with time management.

    Attributes:
        name: Task name
        priority: Task priority (higher number = higher priority)
        id: Unique task identifier (auto-generated by repository)
        status: Current task status (PENDING, IN_PROGRESS, COMPLETED, CANCELED)
        created_at: Created at timestamp
        updated_at: Updated at timestamp (automatically managed by repository)
        planned_start: Planned start datetime
        planned_end: Planned end datetime
        deadline: Deadline datetime
        actual_start: Actual start datetime (set when status → IN_PROGRESS)
        actual_end: Actual end datetime (set when status → COMPLETED/CANCELED)
        estimated_duration: Estimated duration in hours
        daily_allocations: Daily work hours allocation (date_str → hours)
        depends_on: List of task IDs that must be completed before this task can start
        is_fixed: Whether this task is fixed (cannot be moved by optimizer)
        actual_daily_hours: Actual work hours per day (date_str → hours)
        tags: List of tags for categorization and filtering (non-empty, unique)
        is_archived: Whether this task is archived (soft deleted)

    Design Notes:
        Archive Implementation (2025-10-31):
        - Archiving is implemented as is_archived boolean flag to preserve original task status
        - This aligns with industry standards (Jira, Trello) where archiving is
          a visibility flag rather than a terminal state
        - Benefits:
          * Original status (COMPLETED, CANCELED, etc.) is preserved
          * Restoring returns task to its exact previous state
          * More intuitive: "archived COMPLETED task" vs "ARCHIVED task"
    """

    name: str
    priority: int
    id: int | None = None
    status: TaskStatus = field(default_factory=lambda: TaskStatus.PENDING)
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    planned_start: datetime | None = None
    planned_end: datetime | None = None
    deadline: datetime | None = None
    actual_start: datetime | None = None
    actual_end: datetime | None = None
    estimated_duration: float | None = None
    daily_allocations: dict[date, float] = field(default_factory=dict)
    # New fields (Phase 1: Schema extension)
    depends_on: list[int] = field(default_factory=list)
    is_fixed: bool = False
    actual_daily_hours: dict[date, float] = field(default_factory=dict)
    tags: list[str] = field(default_factory=list)
    # Archive flag: True = soft deleted, preserves original status
    is_archived: bool = False

    def __post_init__(self) -> None:
        """Validate entity invariants after initialization.

        Ensures that the Task entity always maintains a valid state by checking:
        - Task name is not empty or whitespace-only
        - Priority is a positive integer
        - Estimated duration (if provided) is a positive number
        - Tags are non-empty strings and unique

        Raises:
            TaskValidationError: If any invariant is violated
        """
        # Validate name (required and non-empty)
        if not self.name or not self.name.strip():
            raise TaskValidationError("Task name cannot be empty")

        # Validate priority (must be positive)
        if self.priority <= 0:
            raise TaskValidationError("Priority must be greater than 0")

        # Validate estimated_duration (if provided, must be positive)
        if self.estimated_duration is not None and self.estimated_duration <= 0:
            raise TaskValidationError("Estimated duration must be greater than 0")

        # Validate tags (non-empty strings and unique)
        for tag in self.tags:
            if not tag or not tag.strip():
                raise TaskValidationError("Tag cannot be empty")
        if len(self.tags) != len(set(self.tags)):
            raise TaskValidationError("Tags must be unique")

    @property
    def actual_duration_hours(self) -> float | None:
        """Calculate actual duration in hours from actual_start and actual_end"""
        if not self.actual_start or not self.actual_end:
            return None

        duration = (
            self.actual_end - self.actual_start
        ).total_seconds() / SECONDS_PER_HOUR
        return round(duration, 1)

    @property
    def is_active(self) -> bool:
        """Check if task is in active state (work in progress or pending).

        Returns:
            True if task status is PENDING or IN_PROGRESS
        """
        return self.status in (TaskStatus.PENDING, TaskStatus.IN_PROGRESS)

    @property
    def is_finished(self) -> bool:
        """Check if task is in finished state (completed or canceled).

        Returns:
            True if task status is COMPLETED or CANCELED
        """
        return self.status in (TaskStatus.COMPLETED, TaskStatus.CANCELED)

    @property
    def can_be_modified(self) -> bool:
        """Check if task can be modified (not archived).

        Archived tasks should not be updated.

        Returns:
            True if task is not archived
        """
        return not self.is_archived

    def is_schedulable(self, force_override: bool = False) -> bool:
        """Check if task can be scheduled.

        Args:
            force_override: Whether to allow rescheduling of already-scheduled tasks

        Returns:
            True if task can be scheduled

        Business Rules:
            - Must not be archived
            - Must have estimated_duration set
            - Must be PENDING status (not IN_PROGRESS, COMPLETED, or CANCELED)
            - Must not be fixed (always protected, even with force_override)
            - If force_override is False, must not have existing schedule
        """
        # Skip archived tasks
        if self.is_archived:
            return False

        # Skip finished tasks
        if self.is_finished:
            return False

        # Skip IN_PROGRESS tasks (don't reschedule tasks already being worked on)
        if self.status == TaskStatus.IN_PROGRESS:
            return False

        # Skip tasks without estimated duration
        if not self.estimated_duration:
            return False

        # Skip fixed tasks (always, even with force_override)
        # Fixed tasks represent immovable constraints (meetings, deadlines, etc.)
        if self.is_fixed:
            return False

        # Allow scheduling if no existing schedule OR if force_override is True
        return not (self.planned_start and not force_override)

    def should_count_in_workload(self) -> bool:
        """Check if task should be counted in workload calculations.

        Returns:
            True if task should be included in workload

        Business Rules:
            - Exclude archived tasks
            - Exclude finished tasks (COMPLETED, CANCELED)
            - Include PENDING and IN_PROGRESS tasks
        """
        return not self.is_archived and not self.is_finished

    # State transition methods (Command methods for encapsulation)

    def start(self, timestamp: datetime) -> None:
        """Start the task and record timestamp.

        Args:
            timestamp: The time when the task is started

        Side effects:
            - Changes status to IN_PROGRESS
            - Sets actual_start if not already set
        """
        if self.status == TaskStatus.IN_PROGRESS:
            return  # Already started

        self.status = TaskStatus.IN_PROGRESS
        if not self.actual_start:
            self.actual_start = timestamp

    def complete(self, timestamp: datetime) -> None:
        """Complete the task and record timestamp.

        Args:
            timestamp: The time when the task is completed

        Side effects:
            - Changes status to COMPLETED
            - Sets actual_end if not already set
        """
        if self.status == TaskStatus.COMPLETED:
            return  # Already completed

        self.status = TaskStatus.COMPLETED
        if not self.actual_end:
            self.actual_end = timestamp

    def cancel(self, timestamp: datetime) -> None:
        """Cancel the task and record timestamp.

        Args:
            timestamp: The time when the task is canceled

        Side effects:
            - Changes status to CANCELED
            - Sets actual_end if not already set
        """
        if self.status == TaskStatus.CANCELED:
            return  # Already canceled

        self.status = TaskStatus.CANCELED
        if not self.actual_end:
            self.actual_end = timestamp

    def pause(self) -> None:
        """Pause the task and clear time tracking.

        Side effects:
            - Changes status to PENDING
            - Clears actual_start and actual_end
        """
        self.status = TaskStatus.PENDING
        self.actual_start = None
        self.actual_end = None

    def reopen(self) -> None:
        """Reopen a finished task back to PENDING.

        Side effects:
            - Changes status to PENDING
            - Clears actual_start and actual_end
        """
        self.status = TaskStatus.PENDING
        self.actual_start = None
        self.actual_end = None

    # Schedule management methods

    def set_schedule(
        self,
        start: datetime,
        end: datetime,
        allocations: dict[date, float] | None = None,
    ) -> None:
        """Set the task schedule.

        Args:
            start: Planned start datetime
            end: Planned end datetime
            allocations: Optional daily work hours allocation

        Side effects:
            - Sets planned_start and planned_end
            - Sets daily_allocations if provided
        """
        self.planned_start = start
        self.planned_end = end
        if allocations is not None:
            self.daily_allocations = allocations

    def clear_schedule(self) -> None:
        """Clear the task schedule.

        Side effects:
            - Clears planned_start, planned_end, and daily_allocations
        """
        self.planned_start = None
        self.planned_end = None
        self.daily_allocations = {}

    def set_daily_allocations(self, allocations: dict[date, float]) -> None:
        """Set daily work hours allocation.

        Args:
            allocations: Dictionary mapping dates to work hours

        Side effects:
            - Replaces daily_allocations
        """
        self.daily_allocations = allocations

    # Dependency management methods

    def add_dependency(self, task_id: int) -> None:
        """Add a dependency to this task.

        Args:
            task_id: ID of the task that must be completed before this task

        Side effects:
            - Adds task_id to depends_on list if not already present
        """
        if task_id not in self.depends_on:
            self.depends_on.append(task_id)

    def remove_dependency(self, task_id: int) -> None:
        """Remove a dependency from this task.

        Args:
            task_id: ID of the dependency to remove

        Side effects:
            - Removes task_id from depends_on list if present
        """
        if task_id in self.depends_on:
            self.depends_on.remove(task_id)
